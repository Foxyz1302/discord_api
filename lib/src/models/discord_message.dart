import 'discord_application.dart';
import 'discord_attachment.dart';
import 'discord_channel.dart';
import 'discord_channel_mention.dart';
import 'discord_embed.dart';
import 'discord_guild_member.dart';
import 'discord_message_activity.dart';
import 'discord_message_component.dart';
import 'discord_message_flag.dart';
import 'discord_message_interaction.dart';
import 'discord_message_reference.dart';
import 'discord_message_type.dart';
import 'discord_snowflake.dart';
import 'discord_reaction.dart';
import 'discord_sticker.dart';
import 'discord_sticker_item.dart';
import 'discord_user.dart';

class DiscordMessage {
  /// id of the message
  final DiscordSnowflake id;

  /// id of the channel the message was sent in
  final DiscordSnowflake? channelId;

  /// id of the guild the message was sent in
  final DiscordSnowflake? guildId;

  /// the author of this message (not guaranteed to be a vlid user, see below)
  ///
  /// * The author object follows the structure of the user object,
  /// but is only a valid user in the case where the message is
  /// generated by a user or bot user. If the message is generated by
  /// webhook, the author object corresponds to the webhook's id,
  /// username, and avatar. You can tell if a message is generated by
  /// a webhook by checking for the `webhook_id` on the message object.
  final DiscordUser author; //can be a fake user, such as a webhook

  /// member properties for this message's author
  ///
  /// * The member object exists in [MESSAGE_CREATE](https://discord.com/developers/docs/topics/gateway#message-create)
  /// and [MESSAGE_UPDATE](https://discord.com/developers/docs/topics/gateway#message-update)
  /// events from text-based guild channels, provided that the author of
  /// the message is not a webhook. This allows bots to obtain real-time
  /// member data without requiring bots to store member state in memory.
  ///
  /// is not always returned, hence the nullable property
  final DiscordGuildMember? member;

  /// contents of the message
  final String content;

  /// when this message was sent,
  /// as an ISO 8601 datetime string
  final String timestamp;

  late final DateTime? _timestampAsDateTime;

  /// when this message edited (or null if never),
  /// as an ISO 8601 datetime string
  ///
  /// can be null
  final String? editedTimestamp;

  late final DateTime? _editedTimestampAsDateTime;

  /// whether this was a TTS message
  final bool tts;

  /// whether this message mentions everyone
  final bool mentionEveryone;

  /// users specifically mentioned in this message*
  ///
  /// * The user objects in the mentions array will only have the partial
  /// `member` field present in [MESSAGE_CREATE](https://discord.com/developers/docs/topics/gateway#message-create)
  /// and [MESSAGE_UPDATE](https://discord.com/developers/docs/topics/gateway#message-update)
  /// events from text-based guild channels.
  final List<DiscordUser> mentions;

  /// roles specifically mentioned in this message
  final List<String> mentionRoles;

  /// channels specifically mentioned in this message
  ///
  /// * Not all channel mentions in a message will appear in `mention_channels`.
  /// Only textual channels that are visible to everyone in a lurkable guild
  /// will ever be included. Only crossposted messages (via Channel Following)
  /// currently include `mention_channels` at all. If no mentions in the
  /// message meet these requirements, this field will not be sent.
  ///
  /// is not always returned, hence the nullable property
  final List<DiscordChannelMention>? mentionChannels;

  /// any attached files
  final List<DiscordAttachment> attachments;

  /// any embedded content
  final List<DiscordEmbed> embeds;

  /// reactions to the message
  final List<DiscordReaction>? reactions;

  /// user for validating a message was sent
  ///
  /// Can be sent as either integer or string. In doubt,
  /// we will put both in Strings.
  ///
  /// is not always returned, hence the nullable property
  final String? nonce;

  /// whether this message is pinned
  final bool pinned;

  /// if the message is generated by a webhook, this is the webhook's id
  ///
  /// is not always returned, hence the nullable property
  final DiscordSnowflake? webhookId;

  /// [type of message](https://discord.com/developers/docs/resources/channel#message-object-message-types)
  final int type;

  late final DiscordMessageType? _typeAsEnum;

  /// sent with Rich Presence-related chat embeds
  ///
  /// is not always returned, hence the nullable property
  final DiscordMessageActivity? activity;

  /// sent with Rich Presence-related chat embeds
  ///
  /// is not always returned, hence the nullable property
  final DiscordApplication? application;

  /// if the message is an [Interaction](https://discord.com/developers/docs/interactions/receiving-and-responding)
  /// or application-owned webh]ook, this is the id of the application
  ///
  /// is not always returned, hence the nullable property
  final DiscordSnowflake? applicationId;

  /// data showing the source of a crosspost, channel follow
  /// add, pin, or reply message
  ///
  /// is not always returned, hence the nullable property
  final DiscordMessageReference? messageReference;

  /// [message flags](https://discord.com/developers/docs/resources/channel#message-object-message-flags)
  /// combined as a [bitfield](https://en.wikipedia.org/wiki/Bit_field)
  ///
  /// is not always returned, hence the nullable property
  final int? flags;

  late final List<DiscordMessageFlag>? _flagsAsEnum;

  /// the message associated with the message_reference
  ///
  /// * This field is only returned for messages with a `type`
  /// of `19` (REPLY) or `21` (THREAD_STARTER_MESSAGE). If the
  /// message is a reply but the `referenced_message` field is
  /// not present, the backend did not attempt to fetch the message
  /// that was being replied to, so its state is unknown. If the
  /// field exists but is null, the referenced message was deleted.
  ///
  /// is not always returned, and can be null
  final DiscordMessage? referencedMessage;

  /// local boolean that's set to true if [referencedMessage] was returned,
  /// to distinguish between the not existant field and the null field
  final bool isReferencedMessageReturned;

  /// sent if the message is a response to an [Interaction](https://discord.com/developers/docs/interactions/receiving-and-responding)
  final DiscordMessageInteraction? interaction;

  /// the thread that was started from this message, includes [thread member](https://discord.com/developers/docs/resources/channel#thread-member-object)
  /// object
  ///
  /// is not always returned, hence the nullable property
  final DiscordChannel? thread;

  /// sent if the message contains components like buttons,
  /// action rows, or other interactive components
  ///
  /// the top row components always are an Action Row, type 1
  ///
  /// is not always returned, hence the nullable property
  final List<DiscordMessageComponent>? components;

  /// sent if the message contains stickers
  ///
  /// is not always returned, hence the nullable property
  final List<DiscordStickerItem>? stickerItems;

  /// **Deprecated** the stickers sent with the message
  ///
  /// is not always returned, hence the nullable property
  @Deprecated('Use stickerItems instead')
  final List<DiscordSticker>? stickers;

  static const idEntry = 'id';
  static const channelIdEntry = 'channel_id';
  static const guildIdEntry = 'guild_id';
  static const authorIdEntry = 'author';
  static const memberEntry = 'member';
  static const contentEntry = 'content';
  static const timestampEntry = 'timestamp';
  static const editedTimestampEntry = 'edited_timestamp';
  static const ttsEntry = 'tts';
  static const mentionEveryoneEntry = 'mention_everyone';
  static const mentionsEntry = 'mentions';
  static const mentionRolesEntry = 'mention_roles';
  static const mentionChannelsEntry = 'mention_channels';
  static const attachmentsEntry = 'attachments';
  static const embedsEntry = 'embeds';
  static const reactionsEntry = 'reactions';
  static const nonceEntry = 'nonce';
  static const pinnedEntry = 'pinned';
  static const webhookIdEntry = 'webhook_id';
  static const typeEntry = 'type';
  static const activityEntry = 'activity';
  static const applicationEntry = 'application';
  static const applicationIdEntry = 'application_id';
  static const messageReferenceEntry = 'message_reference';
  static const flagsEntry = 'flags';
  static const referencedMessageEntry = 'referenced_message';
  static const interactionEntry = 'interaction';
  static const threadEntry = 'thread';
  static const componentsEntry = 'components';
  static const stickerItemsEntry = 'sticker_items';
  static const stickersEntry = 'stickers';

  DiscordMessage({
    required this.id,
    this.channelId,
    this.guildId,
    required this.author,
    this.member,
    required this.content,
    required this.timestamp,
    this.editedTimestamp,
    required this.tts,
    required this.mentionEveryone,
    required this.mentions,
    required this.mentionRoles,
    this.mentionChannels,
    required this.attachments,
    required this.embeds,
    this.reactions,
    this.nonce,
    required this.pinned,
    this.webhookId,
    required this.type,
    this.activity,
    this.application,
    this.applicationId,
    this.messageReference,
    required this.isReferencedMessageReturned,
    this.flags,
    this.referencedMessage,
    this.interaction,
    this.thread,
    this.components,
    this.stickerItems,
    this.stickers,
  });

  DateTime get timestampAsDateTime =>
      _timestampAsDateTime ??= DateTime.parse(timestamp);

  DateTime? get editedTimestampAsDateTime {
    if (editedTimestamp == null) return null;
    return _editedTimestampAsDateTime ??= DateTime.parse(editedTimestamp!);
  }

  DiscordMessageType get typeAsEnum =>
      _typeAsEnum ??= DiscordMessageType.values[type];

  // TODO: Recover Message Flags from Bitset
  // List<DiscordMessageFlag> get flagsAsEnum {}

  factory DiscordMessage.fromJson(Map<String, dynamic> json) => DiscordMessage(
        id: DiscordSnowflake(json[idEntry] as String),
        channelId: json[channelIdEntry] != null
            ? DiscordSnowflake(json[channelIdEntry] as String)
            : null,
        guildId: json[guildIdEntry] != null
            ? DiscordSnowflake(json[guildIdEntry] as String)
            : null,
        author:
            DiscordUser.fromJson(json[authorIdEntry] as Map<String, dynamic>),
        member: json[memberEntry] != null
            ? DiscordGuildMember.fromJson(
                json[memberEntry] as Map<String, dynamic>)
            : null,
        content: json[contentEntry] as String,
        timestamp: json[timestampEntry] as String,
        editedTimestamp: json[editedTimestampEntry] as String?,
        tts: json[ttsEntry] as bool,
        mentionEveryone: json[mentionEveryoneEntry] as bool,
        mentions: List<DiscordUser>.from(
            (json[mentionsEntry]).map(DiscordUser.fromJson)),
        mentionRoles: List<String>.from(json[mentionRolesEntry]),
        mentionChannels: List<DiscordChannelMention>.from(
            (json[mentionChannelsEntry]).map(DiscordChannelMention.fromJson)),
        attachments: List<DiscordAttachment>.from(
            (json[attachmentsEntry]).map(DiscordAttachment.fromJson)),
        embeds: List<DiscordEmbed>.from(
            (json[embedsEntry]).map(DiscordEmbed.fromJson)),
        reactions: json[reactionsEntry] != null
            ? List<DiscordReaction>.from(
                (json[reactionsEntry]).map(DiscordReaction.fromJson))
            : null,
        nonce: json[nonceEntry] as String?,
        pinned: json[pinnedEntry] as bool,
        webhookId: json[webhookIdEntry] != null
            ? DiscordSnowflake(json[webhookIdEntry] as String)
            : null,
        type: json[typeEntry] as int,
        activity: json[activityEntry] != null
            ? DiscordMessageActivity.fromJson(
                json[activityEntry] as Map<String, dynamic>)
            : null,
        application: json[applicationEntry] != null
            ? DiscordApplication.fromJson(
                json[applicationEntry] as Map<String, dynamic>)
            : null,
        applicationId: json[applicationIdEntry] != null
            ? DiscordSnowflake(json[applicationIdEntry] as String)
            : null,
        messageReference: json[messageReferenceEntry] != null
            ? DiscordMessageReference.fromJson(
                json[messageReferenceEntry] as Map<String, dynamic>)
            : null,
        isReferencedMessageReturned:
            json.containsKey(referencedMessageEntry) ? true : false,
        flags: json[flagsEntry] as int?,
        referencedMessage: json[referencedMessageEntry] != null
            ? DiscordMessage.fromJson(
                json[referencedMessageEntry] as Map<String, dynamic>)
            : null,
        interaction: json[interactionEntry] != null
            ? DiscordMessageInteraction.fromJson(
                json[interactionEntry] as Map<String, dynamic>)
            : null,
        thread: json[threadEntry] != null
            ? DiscordChannel.fromJson(json[threadEntry] as Map<String, dynamic>)
            : null,
        components: json[componentsEntry] != null
            ? List<DiscordMessageComponent>.from(
                (json[componentsEntry]).map(DiscordMessageComponent.fromJson),
              )
            : null,
        stickerItems: json[stickerItemsEntry] != null
            ? List<DiscordStickerItem>.from(
                (json[stickerItemsEntry]).map(DiscordStickerItem))
            : null,
        stickers: json[stickersEntry] != null
            ? List<DiscordSticker>.from(
                (json[stickersEntry]).map(DiscordSticker))
            : null,
      );
}
